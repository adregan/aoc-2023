# Advent of Code 2023

```elixir
Mix.install([
  {:kino_aoc, "~> 0.1"}
])
```

## Utils

```elixir
defmodule AOC do
  def solve(module) do
    for part <- 1..2 do
      apply(module, :solve, [part])
      |> then(&IO.inspect("Part #{part}: #{inspect(&1)}"))
    end
  end
end
```

## Day 1

<!-- livebook:{"attrs":{"assign_to":"day_1_input","day":"1","session_secret":"AOC_SESSION","year":"2023"},"chunks":null,"kind":"Elixir.KinoAOC.HelperCell","livebook_object":"smart_cell"} -->

```elixir
{:ok, day_1_input} =
  KinoAOC.download_puzzle("2023", "1", System.fetch_env!("LB_AOC_SESSION"))
```

```elixir
defmodule Day1 do
  @input day_1_input |> String.split()
  @digits_table ["one", "two", "three", "four", "five", "six", "seven", "eight", "nine"]
                |> Enum.with_index()
                |> Map.new(fn {k, v} -> {k, "#{v + 1}"} end)

  def solve(1) do
    @input
    |> Enum.map(&get_digits/1)
    |> Enum.sum()
  end

  def solve(2) do
    @input
    |> Enum.map(&normalize/1)
    |> Enum.sum()
  end

  defp get_digits(line) do
    Regex.scan(~r/\d/, line)
    |> then(fn ln -> List.first(ln) ++ List.last(ln) end)
    |> Enum.join()
    |> String.to_integer()
  end

  defp normalize(line) do
    pattern = @digits_table |> Map.keys() |> Enum.join("|")

    first =
      ("[0-9]|" <> pattern)
      |> Regex.compile!()
      |> Regex.run(line)
      |> List.first()
      |> convert_digit()

    last =
      ("[0-9]|" <> (pattern |> String.reverse()))
      |> Regex.compile!()
      |> Regex.run(line |> String.reverse())
      |> List.first()
      |> String.reverse()
      |> convert_digit()

    (first <> last) |> String.to_integer()
  end

  defp convert_digit(word) do
    if Enum.member?(Map.values(@digits_table), word) do
      word
    else
      Map.get(@digits_table, word)
    end
  end
end

AOC.solve(Day1)
```
